现在我们已经探索了一些用于构建并行程序的不同模型，现在是时候转向更抽象的分类，并通过探索不同的并行编程语言范式来了解如何编写并行程序的基本风格或原则。

\mySubsubsection{1.3.1.}{同步编程}

同步编程语言用于构建严格按顺序执行代码的程序。执行一条指令时，程序将保持阻塞状态，直到该指令完成。换句话说，没有多任务处理。这使得代码更易于理解和调试。

然而，这种行为使得程序在运行指令时被阻塞，无法响应外部事件，并且难以扩展。
这是大多数编程语言（例如 C、 Python 或 Java）使用的传统范式。

这种模式对于需要实时、有序地响应输入事件的反应式或嵌入式系统尤其有用。处理速度必须与环境所施加的速度相匹配，并有严格的时间限制。

\myGraphic{0.8}{content/part1/chapter1/images/7.png}{图 1.7：异步与同步执行时间}

图 1.7 显示了系统中正在运行的两个任务。在同步系统中，任务 A 被任务 B 中断，并且只有在任务 B 完成其工作后才会恢复执行。在异步系统中，任务 A 和 B 可以同时运行，从而在更短的时间内完成它们的工作。

\mySubsubsection{1.3.2.}{并发编程}

通过并发编程，可以同时运行多个任务。

任务可以独立运行，无需等待其他任务的指令完成。它们还可以共享资源并相互通信。它们的指令可以异步运行，这意味着它们可以按任意顺序执行而不会影响结果，从而增加了并行处理的潜力。另一方面，这使得这种程序更难理解和调试。

并发性提高了程序的吞吐量，因为在一定时间间隔内完成的任务数量会随着并发性的增加而增加（请参阅本章末尾的“探索评估并行性的指标”一节中的古斯塔夫森定律公式）。

此外，它实现了更好的输入和输出响应能力，因为程序可以在等待期间执行其他任务。

并发软件的主要问题是实现正确的并发控制。在协调对共享资源的访问并确保不同计算执行之间发生正确的交互顺序时，必须格外小心。错误的决策可能导致竞争条件、死锁或资源匮乏，这些将在第 3 章和第 4 章中深入解释。大多数这些问题都可以通过遵循一致性或内存模型来解决，该模型定义了在访问共享内存时应如何以及按何种顺序执行操作的规则。

设计高效的并发算法是通过寻找协调任务执行、数据交换、内存分配和调度的技术来最小化响应时间并最大化吞吐量。

第一篇介绍并发的学术论文《并发编程控制问题的解决方案》由 Dijkstra 于 1965 年发表。
论文中也发现并解决了互斥问题。

并发可以在操作系统级别以抢占方式发生，即调度程序无需与任务交互即可切换上下文（ 从一个任务切换到另一个任务）。它也可以以非抢占或协作方式发生，即任务将控制权交给调度程序，调度程序选择另一个任务继续工作。

调度程序通过保存正在运行的程序的状态（内存和寄存器内容）来中断正在运行的程序，然后加载已保存的恢复程序的状态并将控制权移交给该程序。这称为上下文切换。根据任务的优先级，调度程序可能会允许高优先级任务比低优先级任务使用更多的 CPU 时间。

此外，一些特殊的操作软件（例如内存保护）可能会使用特殊硬件来保证监控软件不受用户模式程序错误的损坏。

该机制不仅用于单核计算机，也用于多核计算机，允许执行比可用核心数量多得多的任务。
抢占式多任务处理还允许提前安排重要任务，以便快速处理重要的外部事件。当操作系统向这些任务发送触发中断的信号时，这些任务就会被唤醒并处理重要工作。

旧版 Mac 和 Windows 操作系统使用非抢占式多任务处理。如今， RISC 操作系统仍在使用这种处理方式。 Unix 系统于 1969 年开始使用抢占式多任务处理，这是所有类 Unix 系统和Windows NT 3.1 和 Windows 95 以后的现代 Windows 版本的核心功能。

早期的 CPU 每次只能运行一条指令路径。并行是通过在指令流之间切换来实现的，通过看似重叠的执行，给人一种软件层面并行的假象。

然而， 2005 年，英特尔® 推出了多核处理器，允许在硬件层面同时执行多个指令流。这给编写软件带来了一些挑战，因为现在需要解决和利用硬件层面的并发性。

C++ 自 C++11 起就通过 std::thread 库支持并发编程。早期版本不包含任何特定功能，因此程序员依赖于 Unix 系统中基于 POSIX 线程模型的平台特定库或 Windows 系统中的专有 Mi crosoft 库。

现在我们更好地理解了并发是什么，我们需要区分并发和并行。当许多执行路径可以在重叠的时间段内交错执行时，就会发生并发，而当这些任务由不同的 CPU 单元同时执行，利用可用的多核资源时，就会发生并行。

\myGraphic{0.8}{content/part1/chapter1/images/8.png}{图 1.8：并发与并行}

并发编程被认为比并行编程更通用，因为后者具有预定义的通信模式，而前者可以涉及任务之间的任意和动态的通信和交互模式。

并行可以存在于没有并发性（没有交错的时间段）的情况下，也可以存在于没有并行性（ 通过单核 CPU 上的分时多任务处理）的情况下。

\mySubsubsection{1.3.3.}{异步编程}

异步编程允许安排一些任务在后台运行，同时继续执行当前作业，而无需等待计划的任务完成。当这些任务完成后，它们会将其结果报告给主作业或调度程序。

同步应用程序的一个关键问题是，长时间操作可能会导致程序无法响应进一步的输入或处理。异步程序解决了这个问题，方法是在执行某些操作时接受新输入，同时使用非阻塞任务，并且系统可以一次执行多个任务。这还可以提高资源利用率。

由于任务是异步执行的，并且在完成后会报告结果，因此该范例特别适合事件驱动程序。
此外，它还是一种通常用于用户界面、 Web 服务器、网络通信或长时间运行的后台处理的范例。
随着硬件发展到单个处理器芯片上的多个处理核心，必须使用异步编程来通过在不同核心上并行运行任务来充分利用所有可用的计算能力。

然而，异步编程也有其挑战，正如我们将在本书中探讨的那样。例如，它增加了复杂性，因为代码不是按顺序解释的。这可能导致竞争条件。此外，错误处理和测试对于确保程序稳定性和防止出现问题至关重要。

正如我们将在本书中了解到的，现代 C++ 还提供了异步机制，例如协程（可以暂停并稍后恢复的程序），或者未来和承诺（作为异步程序中未知结果的代理，用于同步程序执行） 。

\mySubsubsection{1.3.4.}{并行编程}

通过并行编程，多个计算任务可以在多个处理单元上同时完成，这些处理单元可以全部位于同一台计算机（多核）上，也可以位于多台计算机（集群）上。

主要有两种方法：

\begin{itemize}
\item
共享内存并行：任务可以通过共享内存（所有处理器都可以访问的内存空间）进行通信

\item
消息传递并行：每个任务都有自己的内存空间，并使用消息传递技术与其他任务进行通信
\end{itemize}

与之前的范例一样，为了充分发挥潜力并避免错误或问题，并行计算需要同步机制以避免任务相互干扰。它还需要平衡工作负载以充分发挥其潜力，以及减少创建和管理任务时的开销。这些需求增加了设计、实施和调试的复杂性。

\mySubsubsection{1.3.5.}{多线程编程}

多线程编程是并行编程的一个子集，其中程序被分成多个线程，在同一进程内执行独立单元。进程、内存空间和资源在线程之间共享。

前面我们已经提到，共享内存需要同步机制。另一方面，由于不需要进程间通信，资源共享变得简单。

例如，多线程编程通常用于实现具有流畅动画的图形用户界面 (GUI) 响应能力、在 Web 服务器中处理多个客户端的请求或用于数据处理。

\mySubsubsection{1.3.6.}{事件驱动式编程}

在事件驱动编程中，控制流由外部事件驱动。应用程序实时检测事件，并通过调用适当的事件处理方法或回调来响应这些事件。

事件表示需要采取的操作。事件循环会监听此事件，并不断监听传入的事件，并将其分派给相应的回调，从而执行所需的操作。由于代码仅在发生操作时执行，因此这种模式提高了资源使用效率和可扩展性。

事件驱动编程对于处理用户界面、实时应用程序和网络连接监听器中发生的动作很有用。

与许多其他范式一样，增加的复杂性、同步和调试使得该范式的实现和应用变得复杂。

由于 C++ 是一种低级语言，因此使用回调或函子等技术来编写事件处理程序。

\mySubsubsection{1.3.7.}{响应式编程}

反应式编程处理数据流，即随时间连续的数据或值流。程序通常使用声明式或函数式编程构建，定义应用于流的运算符和转换的管道。这些操作使用调度程序和背压处理机制异步进行。

当数据量超出消费者承受能力，消费者无法处理所有数据时，就会发生背压。为了避免系统崩溃，反应式系统需要使用背压策略来防止系统故障。

其中一些策略包括：

\begin{itemize}
\item
通过请求发布者降低发布事件的速率来控制输入吞吐量。这可以通过遵循拉取策略来实现，即发布者仅在消费者请求时发送事件，或者通过限制发送的事件数量来实现，从而创建有限且受控的推送策略。

\item
缓冲额外的数据，这在短时间内出现数据突发或高带宽传输时尤其有用。

\item
删除一些事件或延迟其发布，直到消费者从背压状态中恢复为止。
\end{itemize}

因此，反应式程序可以是基于拉取的，也可以是基于推送的。基于拉取的程序实现了从数据源主动拉取事件的经典情况。另一方面，基于推送的程序通过信号网络推送事件以到达订阅者。订阅者对变化做出反应而不会阻塞程序，这使得这些系统非常适合响应性至关重要的丰富用户界面环境。

反应式编程就像一个事件驱动模型，其中来自各种来源的事件流可以被转换、过滤、处理等。两者都增加了代码模块化，适用于实时应用程序。但是，也存在一些差异，如下所示：

\begin{itemize}
\item
反应式编程对事件流做出反应，而事件驱动编程处理离散事件。

\item
在事件驱动编程中，事件会触发回调或事件处理程序。通过反应式编程，可以创建具有不同转换运算符的管道，从而让数据流流动并修改事件。
\end{itemize}

使用反应式编程的系统和软件的示例包括 X Windows 系统和 Qt、 WxWidgets 和 Gtk+ 等库。反应式编程还用于实时传感器数据处理和仪表板。此外，它还适用于处理网络或文件 I/O 流量和数据处理。

要充分发挥反应式编程的潜力，在使用反应式编程时需要解决一些挑战。例如，调试分布式数据流和异步进程或通过微调调度程序来优化性能非常重要。此外，使用声明式或函数式编程使得使用反应式编程技术开发软件变得更难理解和学习。

\mySubsubsection{1.3.8.}{数据流编程}

使用数据流编程，程序被设计为有向图，其中节点表示计算单元，边表示数据流。节点仅在有可用数据时执行。这种范式是由麻省理工学院的杰克·丹尼斯于 20 世纪 60 年代发明的。

数据流编程使代码和设计更具可读性和清晰度，因为它提供了不同计算单元及其交互方式的可视化表示。此外，独立节点可以与数据流编程并行运行，从而提高并行性和吞吐量。

因此，它类似于反应式编程，但为建模系统提供了基于图形的方法和视觉辅助。

要实现数据流程序，我们可以使用哈希表。键标识一组输入，值描述要运行的任务。当给定键的所有输入都可用时，将执行与该键相关联的任务，从而生成可能触发哈希表中其他键的任务的其他输入值。在这些系统中，调度程序可以通过对图形数据结构进行拓扑排序来寻找并行机会，按相互依赖性对不同的任务进行排序。

这种范式通常用于机器学习的大规模数据处理管道、传感器或金融市场数据的实时分析以及音频、视频和图像处理系统。使用数据流范式的软件库的示例有 Apache Spark 和 TensorF low。在硬件方面，我们可以找到数字信号处理、网络路由、 GPU 架构、遥测和人工智能等示例。

数据流编程的一种变体是增量计算，即只重新计算依赖于更改的输入数据的输出。这就像当单元格值发生变化时重新计算 Excel 电子表格中受影响的单元格。

现在我们已经了解了不同的并行编程系统、模型和范例，现在是时候介绍一些有助于衡量并行系统性能的指标了。


