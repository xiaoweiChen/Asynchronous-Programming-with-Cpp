现在，是时候转向更抽象的分类，通过探索并行编程语言范式，来了解编写并行程序的风格和原则。

\mySubsubsection{1.3.1.}{同步编程}

同步编程语言用于构建按顺序执行代码的程序。执行一条指令时，程序将保持阻塞状态，直到该指令完成，没有多任务处理。这使得代码更易于理解和调试。

这种行为使得程序在运行指令时阻塞，无法响应外部事件，并且难以扩展。这是大多数编程语言（例如 C、 Python 或 Java）使用的传统范式。

这种模式对于需要实时、有序地响应输入事件的反应式或嵌入式系统尤其有用。处理速度必须与环境所施加的速度相匹配，并有严格的时间限制。

\myGraphic{0.8}{content/part1/chapter1/images/7.png}{图 1.7：异步与同步执行时间}

图 1.7 展示了系统中正在运行的两个任务。同步系统中，任务 A 被任务 B 中断，只有在任务 B 完成其工作后才会恢复执行。异步系统中，任务 A 和 B 可以同时运行，从而在更短的时间内完成工作。

\mySubsubsection{1.3.2.}{并发编程}

通过并发编程，可以同时运行多个任务。任务可以独立运行，无需等待其他任务完成，还可以共享资源并相互通信。其指令可以异步运行，可以按任意顺序执行，而不会影响结果，增加了并行处理的潜力。不过，这使得程序难以理解和调试。

因为在一定时间间隔内完成的任务数量会随着并发性而增加（古斯塔夫森定律公式），所以并发性提高了程序的吞吐量。

此外，因为可以在等待期间执行其他任务，程序有更好的输入和输出响应能力。

并发软件的问题是实现正确的并发控制。协调对共享资源的访问并确保不同计算执行之间发生正确的交互顺序时，必须格外小心。错误的决策可能导致竞争条件、死锁或资源短缺。这些问题大多可以通过一致性或内存模型来解决，该模型定义了在访问共享内存时按何种顺序执行操作的规则。

设计高效并发算法是通过寻找协调任务执行、数据交换、内存分配和调度的技术，来最小化响应时间并最大化吞吐量。

第一篇介绍并发的学术论文《并发编程控制问题的解决方案》由 Dijkstra 于 1965 年发表，论文中也发现并解决了互斥问题。

并发的抢占会发生在操作系统级，即调度程序无需与任务交互即可切换上下文（ 从一个任务切换到另一个任务）。也可以以非抢占或协作方式发生，即任务将控制权交给调度程序，调度程序选择另一个任务继续。

调度程序通过保存程序的状态（内存和寄存器内容）来中断正在运行的程序，然后加载已保存的状态并将控制权移交给该程序，这称为上下文切换。根据任务的优先级，调度程序会允许高优先级任务比低优先级任务使用更多的 CPU 时间。

此外，一些特殊的操作软件（例如内存保护）会使用特殊硬件来保证监控软件不受用户模式程序错误的损坏。

该机制不仅用于单核计算机，也用于多核计算机，允许执行比可用核心数量多的任务。抢占式多任务处理还允许提前安排重要任务，以便快速处理重要的外部事件。当操作系统向这些任务发送触发中断的信号时，这些任务就会唤醒并处理重要工作。

旧版 Mac 和 Windows 操作系统使用非抢占式多任务处理。如今， RISC 操作系统仍在使用这种处理方式。 Unix 系统于 1969 年开始使用抢占式多任务处理，这是所有类 Unix 系统、Windows NT 3.1 和 Windows 95 以后 Windows 系统的核心功能。

早期的 CPU 每次只能运行一条指令路径。并行通过在指令流之间切换来实现，通过看似重叠的执行，给人一种并行的假象。

2005 年，英特尔推出了多核处理器，允许在硬件层面同时执行多个指令流。这给编写软件带来了一些挑战，需要解决和利用硬件层面的并发性。

C++11通过 std::thread 库支持并发编程。C++早期版本不包含该功能，因此开发者依赖于 Unix 系统中基于 POSIX 线程模型的平台特定库或 Windows 系统中的专有 Microsoft 库。

为了更好地理解了并发是什么，需要区分并发和并行。当许多执行路径可以在重叠的时间段内交错执行时，就会发生\textbf{并发}；而这些任务由不同的 CPU 单元同时执行，并利用可用的多核资源时，就会发生\textbf{并行}。

\myGraphic{0.8}{content/part1/chapter1/images/8.png}{图 1.8：并发与并行}

并发编程会比并行编程更通用，后者具有预定的通信模式，而前者可以涉及任务之间的通信和交互模式。

并行可以存在于没有并发性（没有交错的时间段）的情况，也可以存在于没有并行性（通过单核 CPU 上的分时多任务处理）的情况。

\mySubsubsection{1.3.3.}{异步编程}

异步编程可以安排一些任务在后台运行，同时继续执行当前作业，而无需等待计划的任务完成。当这些任务完成后，它们会将其结果报告给主作业或调度程序。

同步应用程序的一个关键问题是，长时间操作可能会导致程序无法响应接下来的输入或处理。异步程序解决了这个问题，在执行某些操作时可以接收新的输入，同时创建非阻塞任务，并且系统可以一次执行多个任务，提高资源的利用率。

由于异步执行任务，并且在完成后会报告结果，所以该范例特别适合事件驱动程序。此外，它还是一种通常用于用户界面、 Web 服务器、网络通信或长时间运行的后台处理的范例。随着硬件发展到单个处理器芯片上的多个处理核心，可以使用异步编程来通过在不同核心上并行运行任务，充分利用所有可用的计算能力。

异步编程也有其挑战，例如：增加了复杂性，以及竞争条件。此外，错误处理和测试对于确保程序稳定性和避免出现问题也至关重要。

现代 C++ 还提供了异步机制，例如协程（可以暂停并稍后恢复的程序），或者future和promise（作为异步程序中未知结果的代理，用于同步程序执行） 。

\mySubsubsection{1.3.4.}{并行编程}

通过并行编程，多个计算任务可以在多个处理单元上同时完成，这些处理单元可以全部位于同一台计算机（多核）上，也可以位于多台计算机（集群）。

主要有两种方法：

\begin{itemize}
\item
共享内存并行：任务可以通过共享内存（所有处理器都可以访问的内存空间）进行通信

\item
消息传递并行：每个任务都有自己的内存空间，并使用消息传递技术与其他任务进行通信
\end{itemize}

与之前的范例一样，为了充分发挥潜力并避免错误或问题，并行计算需要同步机制以避免任务相互干扰。还需要平衡工作负载以充分发挥其潜力，以及减少创建和管理任务时的开销。这些需求增加了设计、实施和调试的复杂性。

\mySubsubsection{1.3.5.}{多线程编程}

多线程编程是并行编程的一个子集，其中程序可分成多个线程，在同一进程内执行独立单元。进程、内存空间和资源在线程之间共享。

前面我们已经提到，共享内存需要同步机制。另一方面，由于不需要进程间通信，资源共享变得简单。例如，多线程编程通常用于实现具有流畅动画的图形用户界面 (GUI) 响应能力、在 Web 服务器中处理多个客户端的请求或数据处理。

\mySubsubsection{1.3.6.}{事件驱动式编程}

事件驱动编程中，控制流由外部事件驱动。应用程序实时检测事件，并通过调用适当的事件处理方法或回调来响应这些事件。

事件表示需要采取的操作。事件循环会监听此事件，并不断监听传入的事件，并将其分派给相应的回调，从而执行所需的操作。由于代码仅在发生操作时执行，因此这种模式提高了资源使用效率和可扩展性。

事件驱动编程对于处理用户界面、实时应用程序和网络连接监听器中发生的动作很有用。与许多其他范式一样，增加的复杂性、同步和调试使得该范式的实现和应用变得复杂。由于 C++ 是一种低级语言，需要使用回调或函子等技术来编写事件处理程序。

\mySubsubsection{1.3.7.}{响应式编程}

反应式编程处理数据流，即随时间连续的数据或值流。程序通常使用声明式或函数式编程构建，定义应用于流的运算符和转换的管道。这些操作使用调度程序和背压处理机制异步进行。

当数据量超出消费者承受能力，消费者无法处理所有数据时，就会发生背压。为了避免系统崩溃，反应式系统需要使用背压策略来防止系统故障。

其中一些策略包括：

\begin{itemize}
\item
通过请求发布者降低发布事件的速率来控制输入吞吐量。这可以通过遵循拉取策略来实现，即发布者仅在消费者请求时发送事件，或者通过限制发送的事件数量来实现，从而创建有限且受控的推送策略。

\item
缓冲多余的数据，这在短时间内出现数据突发或高带宽传输时尤其有用。

\item
删除一些事件或延迟其发布，直到消费者从背压状态中恢复为止。
\end{itemize}

反应式程序可以基于拉取，也可以基于推送。基于拉取的程序实现了从数据源主动拉取事件的经典情况，基于推送的程序通过信号网络推送事件以到达订阅者。订阅者对变化做出反应而不会阻塞程序，这使得这些系统非常适合响应性敏感的用户界面环境。

反应式编程就像一个事件驱动模型，其中来自各种来源的事件流可以转换、过滤、处理等。两者都增加了代码的模块化，适用于实时应用程序。但二者也存在一些差异：

\begin{itemize}
\item
反应式编程会对事件流做出反应，而事件驱动编程处理离散事件。

\item
事件驱动编程中，事件会触发回调或事件处理程序。通过反应式编程，可以创建具有不同转换运算符的管道，让数据流流动并修改事件。
\end{itemize}

使用反应式编程的系统和软件的示例包括 X Windows 系统和 Qt、 WxWidgets 和 Gtk+ 等库。反应式编程还用于实时传感器数据处理和仪表板，还适用于处理网络或文件 I/O 流量和数据处理。

要充分发挥反应式编程的潜力，在使用反应式编程时需要解决一些挑战。例如，调试分布式数据流和异步进程或通过微调调度程序来优化性能。此外，使用声明式或函数式编程，会让使用反应式编程技术开发软件变得更难理解和学习。

\mySubsubsection{1.3.8.}{数据流编程}

使用数据流编程，程序设计为有向图，其中节点表示计算单元，边表示数据流，节点仅在有可用数据时执行。这种范式是由麻省理工学院的杰克·丹尼斯于 20 世纪 60 年代发明的。

数据流编程使代码和设计更具可读性和清晰度，提供了不同计算单元及其交互方式的可视化表示。此外，独立节点可以与数据流编程并行运行，从而提高并行性和吞吐量。

类似于反应式编程，但为建模系统提供了基于图形的方法和视觉辅助。

要实现数据流程序，可以使用哈希表。键标识一组输入，值描述要运行的任务。当给定键的所有输入都可用时，将执行与该键相关联的任务，从而生成触发哈希表中其他键的任务的其他输入值。在这些系统中，调度程序可以通过对图形数据结构进行拓扑排序来寻找并行机会，按相互依赖性对不同的任务进行排序。

这种范式通常用于机器学习的大规模数据处理管道、传感器或金融市场数据的实时分析，以及音频、视频和图像处理系统。使用数据流范式的软件库的示例有 Apache Spark 和 TensorFlow。在硬件方面，可以找到数字信号处理、网络路由、 GPU 架构、遥测和人工智能等示例。

数据流编程的一种变体是增量计算，即只重新计算依赖于更改的输入数据的输出。这就像当单元格值发生变化时重新计算 Excel 电子表格中受影响的单元格。

\hspace*{\fill}

了解了不同的并行编程系统、模型和范例，现在是时候介绍一些有助于衡量并行系统性能的指标了。


