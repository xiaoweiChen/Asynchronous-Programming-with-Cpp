在本章中，我们学习了如何使用 C++ 标准库提供的基于锁的同步原语。

我们首先解释了竞争条件和互斥的必要性。然后，我们研究了 std::mutex 以及如何使用它来解决竞争条件。我们还了解了使用锁进行同步时的主要问题：死锁和活锁。

在学习了互斥锁之后，我们研究了条件变量，并使用互斥锁和条件变量实现了同步队列。最后，我们了解了 C++20 中引入的新同步原语：信号量、闩锁和栅栏。

最后，我们研究了 C++ 标准库提供的仅运行一次函数的机制。

在本章中，我们了解了线程同步的基本构成要素以及多线程异步编程的基础。基于锁的线程同步是同步线程最常用的方法。

在下一章中，我们将研究无锁线程同步。我们将首先回顾 C++20 标准库提供的原子性、原子操作和原子类型。我们将展示无锁绑定单生产者单消费者队列的实现。我们还将介绍 C ++ 内存模型。