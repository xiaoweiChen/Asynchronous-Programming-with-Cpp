开始 C++ 中实现协程之前，将从概念上介绍协程，并了解其在程序中有何用处。

从定义开始。协程是一种可以自行暂停的函数，在等待输入值时（暂停时不会执行）或在产生值（例如计算结果）后自行暂停。当输入值可用或调用者请求另一个值，协程就会恢复执行。我们很快会回到 C++ 中的协程，通过一个实际例子来了解协程的工作原理。

想象一下有人在做助理，一天的开始就是阅读电子邮件。其中一封电子邮件是一份报告请求。阅读完电子邮件后，开始撰写所要求的文档。写完介绍段落后，注意到需要同事的另一份报告来获取上一季度的一些会计结果。停止撰写报告，给同事写一封电子邮件请求所需的信息，然后阅读下一封电子邮件，这是一份预订下午重要会议会议室的请求。打开公司开发的用于自动预订会议室的特殊应用程序，以优化会议室的使用并预订会议室。

过了一会儿，又从同事那里收到所需的会计数据并继续撰写报告。

助理总是忙于完成自己的任务。编写报告就是协程的一个很好的例子：开始编写报告，然后在等待所需信息时暂停写作，当信息到达，他们就会继续写作。当然，助理不想浪费时间，在等待期间，也会执行其他任务。如果同事等待请求然后发送适当的响应，则可以将其视为另一个协程。

现在回到软件上。假设需要编写一个函数，在处理一些输入信息后将数据存储在数据库中。

如果数据一次性全部到达，可以只实现一个函数。该函数将读取输入，对其进行所需的处理，最后将结果写入数据库。但如果数据要处理的数据以块的形式到达，并且处理每个块都需要前一个块处理的结果（为了这个例子，假设第一个块处理只需要一些默认值）？解决问题的一个可能方法是让函数等待每个数据块，处理它后将结果存储在数据库中，然后等待下一个数据块，依此类推。但如果这样做，可能会在等待每个数据块到达时浪费大量时间。

阅读完前面的章节后，可能会考虑不同的潜在解决方案：可以创建一个线程来读取数据，将块复制到队列，然后第二个线程（可能是主线程）将处理数据。这是一个可接受的解决方案，但使用多个线程可能有点过头了。

另一个解决方案可能是实现一个函数来仅处理一个块。调用者将等待输入传递给函数，并保留处理每个数据块所需的前一个块处理的结果。这个解决方案中，必须将数据处理函数所需的状态保存在另一个函数中。对于一个简单的示例来说，这可能是可以接受的，但是当处理变得更加复杂（例如，需要保留具有不同中间结果的多个步骤），代码可能很难理解和维护。

可以使用协程来解决这个问题。来看一些可能的协程伪代码，以块的形式处理数据并保留中间结果：

\begin{cpp}
processing_result process_data(data_block data) {
    while (do_processing == true) {
        result_type result{ 0 };
        result = process_data_block(previous_result);
        update_database();
        yield result;
    }
}
\end{cpp}

上述协程从调用者处接收一个数据块，执行所有处理，更新数据库，并保存处理下一个块所需的结果。将结果交给调用者后（稍后将详细介绍如何交出结果），其会自行暂停。当调用者再次调用协程并请求处理新数据块时，协程将恢复执行。

这样的协同程序简化了状态管理，可以在调用之间保持状态。

对协程进行概念性介绍之后，将开始在 C++20 中实现它们。















