在第 4 章中，我们研究了同步队列的实现。我们使用互斥锁和条件变量作为同步原语。与锁同步的数据结构称为阻塞数据结构，因为线程被（操作系统）阻塞，等待锁可用。

不使用锁的数据结构称为非阻塞数据结构。大多数（但不是全部）非阻塞数据结构都是无锁的。

如果每个同步操作在有限的步骤内完成，而不允许无限期地等待条件变为真或假，则数据结构或算法被认为是无锁的。

无锁数据结构的类型如下：

\begin{itemize}
\item
无阻塞：如果所有其他线程都暂停，则线程将在有限的步骤内完成其操作

\item
无锁：当多个线程同时处理数据结构时，一个线程将在有限的步骤内完成其操作

\item
无等待：当多个线程同时处理数据结构时，所有线程将在有限的步骤内完成其操作
\end{itemize}

实现无锁数据结构非常复杂，在实现之前，我们需要确保它是必要的。使用无锁数据结构的原因如下：

\begin{itemize}
\item
实现最大并发性：如前所述，当数据访问同步涉及细粒度数据（如本机类型变量）时，原子操作是一个不错的选择。根据前面的定义，无锁数据结构将允许至少一个访问数据结构的线程在有限数量的步骤中取得一些进展。无等待结构将允许所有访问数据结构的线程取得一些进展。但是，当我们使用锁时，一个线程拥有锁，而其余线程只是等待锁可用，因此使用无锁数据结构可以实现的并发性会好得多。

\item
无死锁：因为不涉及锁，所以我们的代码中不可能出现任何死锁。

\item
性能：某些应用程序必须实现尽可能低的延迟，因此等待锁定是不可接受的。当线程尝试获取锁定但无法获取时，操作系统会阻止该线程。当线程被阻止时，调度程序会进行上下文切换，以便能够调度另一个线程执行。这些上下文切换需要时间，而对于低延迟应用程序（例如高性能网络数据包接收器/处理器），这段时间可能太多了。
\end{itemize}

我们已经了解了什么是阻塞和非阻塞数据结构以及什么是无锁代码。我们将在下一节介绍 C ++ 内存模型。






















