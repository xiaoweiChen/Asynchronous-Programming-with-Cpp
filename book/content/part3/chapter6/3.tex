使用 Promise 和 Future 既有优点，也有缺点。以下是主要缺点。

\mySubsubsection{6.3.1.}{优点}

作为管理异步操作的高级抽象，使用承诺和未来来编写和推理并发代码变得更加简单且不容易出错。

Future 和 Promise 支持并发执行任务，让程序能够高效使用多个 CPU 核心。这可以提高计算密集型任务的性能并缩短执行时间。

此外，它们通过将操作的启动与完成分离来促进异步编程。正如我们稍后将看到的，这对于 I/O 密集型任务（例如网络请求或文件操作）特别有用，在这些任务中，程序可以在等待异步操作完成的同时继续执行其他任务。因此，它们可以返回一个值，也可以返回一个异常，从而允许异常从异步任务传播到等待其完成的调用者代码部分，从而为错误处理和恢复提供了一种更清晰的方式。

正如我们所提到的，它们还提供了一种同步任务完成和检索其结果的机制。这有助于协调并行任务并管理它们之间的依赖关系。

\mySubsubsection{6.3.2.}{缺点}

不幸的是，并非所有都是好消息；有些地区也受到了影响。

例如，使用 Future 和 Promise 进行异步编程可能会在处理任务之间的依赖关系或管理异步操作的生命周期时带来复杂性。此外，如果存在循环依赖关系，则可能会发生死锁。

同样，使用未来和承诺可能会带来一些性能开销，因为在幕后发生的同步机制涉及协调异步任务和管理共享状态。

与其他并发或异步解决方案一样，使用 Future 和 Promise 的代码调试与同步代码相比更具挑战性，因为执行流程可能是非线性的并且涉及多个线程。

现在是时候通过一些示例来解决现实生活中的问题了。