在本章中，我们学习了 std::async，如何使用该函数执行异步任务，如何使用启动策略定义其行为，以及如何处理异常。

我们现在还了解了异步函数返回的 Future 如何影响性能以及如何明智地使用它们。此外，我们还了解了如何使用计数信号量通过系统中可用的线程数来限制异步任务的数量。

我们还提到了一些场景，其中 std::async 可能不是完成这项工作的最佳工具。

最后，我们实现了几个涵盖现实生活场景的示例，这对于并行化许多常见任务很有用。

通过本章获得的所有知识，现在我们知道何时（以及何时不）使用 std::async 函数并行运行异步任务，从而提高应用程序的整体性能，实现更好的计算机资源利用率，并减少资源耗尽。

在下一章中，我们将学习如何使用自 C++20 以来就可用的协程来实现异步执行。