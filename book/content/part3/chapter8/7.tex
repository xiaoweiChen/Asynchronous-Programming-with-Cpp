在前面的部分中，我们实现了几个基本示例来学习主要的 C++ 协程概念。我们首先实现了一个非常基本的协程，以了解编译器对我们的要求：返回类型（有时称为包装器类型，因为它包装了承诺类型）和承诺类型。

即使对于这样一个简单的协程，我们也必须实现我们在编写示例时解释过的一些函数。但有一个函数尚未解释：

\begin{cpp}
void unhandled_exception() noexcept {}
\end{cpp}

我们当时假设协程不会抛出异常，但事实是它们会抛出异常。我们可以在 unhandled\_exception() 函数体中添加处理异常的功能。

协程中的异常可能发生在创建返回类型或承诺类型对象时以及执行协程时（与在正常函数中一样，协程可能会引发异常）。

不同之处在于，如果异常是在协程执行前引发的，则创建协程的代码必须处理该异常，而如果异常是在协程执行时引发的，则会调用 unhandled\_exception()。

第一种情况只是普通的异常处理，没有调用任何特殊函数。我们可以将协程创建放在 try-cat ch 块中，并像在代码中通常做的那样处理可能的异常。

另一方面，如果调用 unhandled\_exception()（在 promise 类型内部），我们必须在该函数内部实现异常处理功能。

有不同的策略来处理此类异常。其中包括：

\begin{itemize}
\item
重新抛出异常，以便我们可以在承诺类型之外（即在我们的代码中）处理它。

\item
终止程序（例如，调用 std::terminate）。

\item
函数为空。在这种情况下，协程将崩溃，很可能会使程序崩溃。
\end{itemize}

因为我们实现的协程非常简单，所以我们将该函数置为空。

在最后一节中，我们介绍了协程的异常处理机制。正确处理异常非常重要。例如，如果您知道协程内部发生异常后，它将无法恢复；那么，最好让协程崩溃并从程序的另一部分（ 通常是从调用者函数）处理异常。






