当任务或计算同时完成时，就会发生并行计算，其中任务是软件应用程序中的执行或工作单元。由于实现并行性的方法有很多，因此了解不同的方法将有助于编写高效的并行算法。这些方法可以通过范例和模型进行描述。

但首先，先对不同的并行计算系统进行分类。

\mySubsubsection{1.2.1.}{系统分类和技术}

并行计算系统最早的分类之一是由 Michael J. Flynn 于 1966 年提出的。 弗林(Flynn)根据并行计算架构可以处理的数据流和指令数量进行了以下分类：

\begin{itemize}
\item
单指令单数据 (SISD) 系统：定义顺序执行程序

\item
单指令多数据 (SIMD) 系统：对大型数据集进行操作，例如：GPU 计算的信号处理数据

\item
多指令单数据 (MISD) 系统：很少使用

\item
多指令多数据 (MIMD) 系统：基于多核和多处理器计算机的(最常见)并行架构
\end{itemize}

\myGraphic{0.5}{content/part1/chapter1/images/1.png}{图 1.1：弗林分类法}

本书不仅介绍了如何使用 C++ 构建软件，还介绍了其如何与底层硬件交互。软件层面上，我们可以进行更有趣的划分或分类，并定义技术。这些，将在后续章节中进行介绍。

\mySamllsection{数据并行}

许多不同的数据单元由在不同处理单元（例如：CPU 或 GPU）中，运行的同一程序或指令序列并行处理。

数据并行性通过相同操作，同时处理多少个不相交的数据集来实现。利用并行性，可以将大型数据集划分为更小且独立的数据块。

因为更多的处理单元可以处理更多的数据，所以该技术还具有高度的可扩展性。

在这个子集中，可以包含 SIMD 指令集，例如 SSE、 AVX、 VMX 或 NEON，这些指令集可通过 C++ 中的内部函数访问。此外，还有用于 NVIDIA GPU 的 OpenMP 和 CUDA 等库。在机器学习训练和图像处理中可以找到它的一些使用示例，该技术与弗林定义的 SIMD 分类有关。

这种分类方式也存在一些缺点——数据必须能够轻松划分为独立的块。这种数据划分和后验合并也会带来一些开销，从而降低并行化的优势。

\mySamllsection{任务并行}

每个CPU核心使用进程或线程运行不同的任务，当这些任务同时接收数据、处理数据并通过消息传递发回它们生成的结果时，就可以实现任务并行。

任务并行的优势在于能够设计异构、细粒度的任务，从而更好地利用处理资源，在设计具有潜在更高加速的解决方案时更加灵活。

根据数据创建的任务之间可能存在依赖关系，并且每个任务的性质不同，因此调度和协调比数据并行更复杂，所以任务创建会增加一些开销。

这里可以引入弗林的 MISD 和 MIMD 分类法，可以在 Web 服务器请求处理系统或用户界面事件处理程序中找到一些示例。

\mySamllsection{流并行}

可将计算分为处理数据子集的各个阶段，来同时处理连续的数据元素序列（也称为数据流）。

阶段可以同时运行。一些阶段生成其他阶段的输入，根据阶段依赖关系构建管道。处理阶段可以将结果发送到下一个阶段，而无需等待整个流数据。

流并行技术在处理连续数据时非常有效。还具有高度可扩展性，可以通过添加更多处理单元来处理更多的输入数据。由于流数据在到达时进行处理，所以无需等待整个数据流发送，内存使用量也减少了。

然而，这些系统也存在一些缺点。由于逻辑处理、错误处理和恢复，这些系统的实现更加复杂。由于还需要实时处理数据流，因此硬件也可能是瓶颈之一。

这些系统的一些示例包括监控系统、传感器数据处理，以及音频和视频流。

\mySamllsection{隐式并行}

编译器、运行时或硬件会并行执行指令。这使得编写并行程序变得更容易，但限制了开发者对所用策略的控制，甚至使分析性能或调试变得更加困难。

\hspace*{\fill}

现在，我们对不同的并行系统和技术有了更好的了解，是时候了解在设计并行程序时可以使用的模型了。

\mySubsubsection{1.2.2.}{并行编程模型}

并行编程模型是一种并行计算机架构，用于表达算法和构建程序。模型越通用，其价值就越大，可以用于更广泛的场景。从这个意义上讲，C++ 通过标准模板库 (STL) 中的库实现了并行模型，可用于实现顺序应用程序中程序的并行执行。

这些模型描述了程序生命周期内，不同任务如何交互以从输入数据中获取结果。其主要区别在于，任务如何交互以及如何处理传入数据。

\mySamllsection{阶段并行}

阶段并行（也称为议程或自由同步范式）中，多个作业或任务并行执行独立计算。在某个时刻，程序需要使用栅栏执行同步交互操作来同步不同的进程。栅栏是一种同步机制，可确保一组任务在其执行过程中到达特定点执行完后，才能继续进行下一个步骤。接下来的步骤将执行其他异步操作，依此类推。

\myGraphic{0.9}{content/part1/chapter1/images/2.png}{图1.2：阶段并行}

这种模型的优点是任务间的交互不会与计算重叠，但各个处理单元之间的工作量和吞吐量很难达到均衡。

\mySamllsection{分而治之}

使用此模型的应用程序使用主任务或作业，将工作量分配给其子任务。子任务并行计算结果将其返回给父任务，父任务将结果合并为最终结果。子任务还可以将分配的任务细分为更小的任务，并创建自己的子任务。

该模型具有与相并联模型相同的缺点，很难实现良好的负载平衡。

\myGraphic{0.5}{content/part1/chapter1/images/3.png}{图 1.3：分而治之模型}

图 1.3 中，可以看到主作业如何将工作划分给几个子任务，以及子任务 2 如何将其分配的工作细分为两个任务。

\mySamllsection{管道模型}

多个任务相互连接，构建虚拟管道。此管道中，各个阶段可以同时运行，并在输入数据时重叠执行。

\myGraphic{1.0}{content/part1/chapter1/images/4.png}{图 1.4：管道模型}

上图中三个任务在由五个阶段组成的流水线中交互，每个阶段都有一些任务在运行，并产生输出结果，供下一个阶段的任务使用。

\mySamllsection{主从模型}

使用主从模型（也称为进程农场），主执行者执行算法的顺序部分，并生成和协调在工作负载中执行并行操作的从属任务。当从属任务完成计算时，将结果通知主执行者，然后主执行者可能会将更多数据发送给从属任务进行处理。

\myGraphic{0.5}{content/part1/chapter1/images/5.png}{图 1.5：主从模型}

缺点是，如果主服务器需要处理太多从服务器或任务太小，主服务器可能会成为瓶颈。在选择由主服务器执行的工作量时，需要权衡每个任务，这也称为任务粒度。当任务较小时，称为细粒度，当任务较大时，称为粗粒度。

\mySamllsection{工作池}

工作池模型中，全局结构保存着要执行的工作项池。主程序会创建作业，从池中获取工作项并执行。

这些作业可以生成更多工作，并将其插入到工作池中。当所有工作都完成后，清空工作池，并行程序便会结束执行。

\myGraphic{0.5}{content/part1/chapter1/images/6.png}{图 1.6：工作池模型}

该机制有利于实现空闲处理单元之间的负载平衡。

在 C++ 中，这个池通常使用无序集合、队列或优先级队列来实现。我们将在本书中后续内容中进行实现。

\hspace*{\fill}

了解了可用于构建并行系统的各种模型，可以继续探索用于开发高效并行任务的并行编程范例了。





























