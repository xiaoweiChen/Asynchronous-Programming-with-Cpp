
进程和线程代表并发执行的两种基本方式，但二者在操作和资源管理方面存在很大差异。进程是正在运行的程序的实例，拥有一系列私有资源，包括内存、文件描述符和执行上下文。进程彼此隔离，单个进程的故障通常不会影响其他进程，从而可为整个系统提供了强大的稳定性。

线程是计算机科学中的一个基本概念，代表在单个进程内执行多个任务的一种轻量且高效的方式。与具有私有内存空间和资源的独立进程不同，线程与其所属的进程交织在一起。这种密切的关系允许线程共享相同的内存空间和资源，包括文件描述符、 堆内存，以及进程分配的其他全局数据。

线程的主要优势是能够高效地通信和共享数据。由于进程内的所有线程共享相同的内存空间，因此可以直接访问和修改公共变量，而无需通过 IPC 机制进行消息的传递。这种共享环境可实现快速数据交换，并有助于实现并发算法和数据结构。

然而，共享同一内存空间也对管理共享资源的访问带来了不小的挑战。为了避免数据损坏并确保共享数据的完整性，线程必须采用同步机制，例如：锁、信号量或互斥锁。这些机制遵循了执行访问共享资源的规则和协议，确保在限定时间内只有一个线程可以访问特定资源。

同步在多线程编程中至关重要，以避免竞争条件、死锁和其他与并发相关的问题。为了应对这些挑战，计算机科学家们开发了各种同步原语和技术。其中包括互斥锁（对共享资源的独占访问）、信号量（对有限数量的资源进行受控访问）和条件变量（使线程能够等待特定条件得到满足后再继续执行）。

通过管理同步并采用适当的并发模式，开发人员可以利用线程的强大功能，在应用程序中实现高性能和可扩展性。线程特别适合可并行化的任务，例如：图像处理、科学模拟和 Web 服务器，可以同时执行多个独立计算。

如前所述，线程是系统线程，所以它们由内核创建和管理。但有些场景中需要大量线程，系统可能没有足够的资源来创建大量系统线程，解决这个问题的方法是使用用户线程。实现用户线程的一种方法是通过协程，协程自 C++20 起已被 C++ 标准支持。

协程是 C++ 中一个较新的功能。协程定义为可在特定点暂停和恢复的函数，可在单个线程内进行协作式多任务处理。与不间断运行的标准函数不同，协程可以暂停执行并将控制权交还给调用者，后者稍后可以从暂停点恢复协程的执行。

协程比系统线程轻量得多，所以可以更快地创建和销毁，并且所需的开销更少。并且协程有协作性，必须明确地将控制权移交给调用者才能切换执行上下文，能使用户程序能够更好地控制协程的执行。

协程可用于创建各种不同的并发模式。例如，协程可用于实现任务，这些任务是可以调度并同时运行的轻量级工作单元。协程还可用于实现通道，属于协程间传递数据的通信通道。

协程可以分为有栈和无栈两类，C++20 协程是无栈的。我们将在第 8 章深入了解这些概念。

总体而言，协程是 C++ 中创建并发程序的强大工具。它们轻量级、协作性强，可用于实现各种不同的并发模式。协程不能完全用于实现并行性，因为其仍然需要 CPU 执行上下文，而这只能由线程提供。

\mySubsubsection{2.3.1.}{线程的生命周期}

系统线程（通常称为轻量级进程）的生命周期包括从创建到终止的各个阶段，每个阶段在并发编程环境中管理和利用线程方面都发挥着至关重要的作用：

\begin{enumerate}
\item
创建：此阶段始于系统中创建新线程时。创建过程涉及使用函数，该函数需要几个参数。一个关键参数是线程的属性，例如：调度策略、堆栈大小和优先级。另一个重要参数是线程将执行的函数，成功创建后，线程将分配堆栈和其他资源。

\item
执行：创建后，线程开始执行其指定的启动函数。在执行期间，线程可以独立执行各种任务，或在必要时与其他线程进行交互。线程还可以创建和管理自己的局部变量和数据结构，使其自成一体并能够同时执行特定任务。

\item
同步：为了确保有序访问共享资源避免数据损坏，线程采用同步机制。常见的同步原语包括锁、信号量和栅栏。适当的同步允许线程协调其活动状态，避免并发编程中可能出现的竞争条件、死锁和其他问题。

\item
终止：线程可以通过多种方式终止，可以显式调用函数来终止自身，也可以通过从其启动函数返回来终止运行。某些情况下，线程可以被另一个使用该函数的线程取消。终止后，系统将回收分配给该线程的资源，并释放该线程持有的待处理操作或锁。
\end{enumerate}

了解系统线程的生命周期，对于设计和实现并发程序至关重要。通过仔细管理线程的创建、执行、同步和终止，开发人员可以创建高效且可扩展的应用程序，以充分利用并发的优势。

\mySubsubsection{2.3.2.}{线程调度}

系统线程由操作系统内核的调度程序管理，具有抢占式调度。调度程序根据线程优先级、分配时间或互斥阻塞等因素，决定何时在线程之间切换执行。这种由内核控制的上下文切换可能会产生大量开销，上下文切换的成本非常高，加上每个线程的资源使用量（例如：其私有的堆栈），使得协程成为更高效替代方案，可以在单个线程中运行多个协程。

协程具有多种优势，减少了与上下文切换相关的开销。由于协程的 Yield 或 Await 对上下文的切换在用户空间代码进行(非内核处理)，该过程更加轻量和高效。这可以显著提高性能，尤其是在上下文切换频繁的情况下。

协程还提供了对线程调度的控制，开发人员可以根据其应用程序的需要定义调度策略。这种灵活性可以微调线程管理、优化资源利用率，并实现所需的性能特征。

协程的另一个重要特性是与系统线程相比，协程通常更轻量。协程不维护自己的堆栈，这是一个很大的资源消耗优势，使其适配资源受限的环境。

总体而言，协程提供了一种更高效、更灵活的线程管理方法，尤其是在需要频繁切换上下文或对线程调度进行细粒度控制的情况下。线程可以访问内存进程，并且该内存由所有线程共享，因此需要小心并控制内存访问。这种控制可通过“同步原语”机制实现。


































