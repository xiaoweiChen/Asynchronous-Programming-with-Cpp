
C++20 引入了新的同步原语来编写多线程应用程序。在本节中，我们将介绍信号量。

信号量是一种计数器，用于管理可用于访问共享资源的许可证数量。信号量可分为两种主要类型：

\begin{itemize}
\item
二进制信号量类似于互斥锁。它只有两种状态： 0 和 1。尽管二进制信号量在概念上类似于互斥锁，但二进制信号量与互斥锁之间存在一些差异，我们将在本节后面看到。

\item
计数信号量可以具有大于 1 的值，用于控制对具有有限数量实例的资源的访问。
\end{itemize}

C++20 实现二进制和计数信号量。

\mySubsubsection{4.7.1.}{二进制信号量}

二进制信号量是一种同步原语，可用于控制对共享资源的访问。它有两种状态： 0 和 1。值为 0 的信号量表示资源不可用，值为 1 的信号量表示资源可用。

二进制信号量可用于实现互斥。这是通过使用二进制信号量来控制对资源的访问来实现的。当一个线程想要访问资源时，它首先检查信号量。如果信号量为 1，则该线程可以访问该资源。如果信号量为 0，则线程必须等到信号量为 1 后才能访问该资源。

互斥锁和信号量之间最显著的区别在于互斥锁具有独占所有权，而二进制信号量则没有。只有拥有互斥锁的线程才能释放它。任何线程都可以向信号量发出信号。互斥锁是临界区的锁定机制，而信号量更像是一种信号机制。在这方面，信号量比互斥锁更接近条件变量。因此，信号量通常用于发出信号，而不是用于互斥。

在 C++20 中， std::binary\_semaphore 是 std::counting\_semaphore 特化的别名，其 LeastMaxValue 为 1。

二进制信号量必须用 1 或 0 初始化，如下所示：

\begin{cpp}
std::binary_semaphore sm1{ 0 };
std::binary_semaphore sm2{ 1 };
\end{cpp}

如果初始值为 0，则获取信号量将阻塞尝试获取它的线程，并且在获取之前，必须由另一个线程释放它。获取信号量会减少计数器，而释放它会增加计数器。如前所述，如果计数器为 0 并且线程尝试获取锁（信号量），则该线程将被阻塞，直到信号量计数器大于 0。

\mySubsubsection{4.7.2.}{计数信号量}

计数信号量允许多个线程访问共享资源。计数器可以初始化为任意数字，并且每次线程获取信号量时，计数器都会减少。作为如何使用计数信号量的一个例子，我们将修改上一节中实现的多线程安全队列，并使用信号量而不是条件变量来同步对队列的访问。

新类的成员变量如下：

\begin{cpp}
template <typename T>
class queue {
// public methods and private helper methods

private:
    std::counting_semaphore<> sem_empty_;
    std::counting_semaphore<> sem_full_;
    std::size_t head_{ 0 };
    std::size_t tail_{ 0 };
    std::size_t capacity_;
    std::vector<T> buffer_;
};
\end{cpp}

我们仍然需要 head\_ 和 tail\_ 来知道在哪里读取和写入元素，需要 capacity\_ 来表示索引的环绕，还需要 buffer\_（一个 std::vector<T> 向量）。但目前，我们不使用互斥锁，我们将使用计数信号量而不是条件变量。我们将使用其中两个： sem\_empty\_ 来计算缓冲区中的空槽（ 初始设置为 capacity\_）， sem\_full\_ 来计算缓冲区中的非空槽，初始设置为 0。
现在，让我们看看如何实现 push，即用于在队列中插入项目的函数。

在 [1] 中，获取 sem\_empty\_，减少信号量计数器。如果队列已满，则线程将阻塞，直到另一个线程释放（发出信号） sem\_empty\_。如果队列未满，则将项目复制到缓冲区，并在 [2] 和 [3] 中更新 tail\_。最后，在 [4] 中释放 sem\_full\_，向另一个线程发出信号，表明队列不为空，并且缓冲区中至少有一个项目：

\begin{cpp}
void push(const T& item) {
    sem_empty_.acquire();

    buffer_[tail_] = item;
    tail_ = next(tail_);

    sem_full_.release();
}
\end{cpp}

pop 函数用于从队列中获取元素：

\begin{cpp}
void pop(T& item) {
    sem_full_.acquire();
    item = buffer_[head_];
    head_ = next(head_);

    sem_empty_.release();
}
\end{cpp}

在这里，在 [1] 中，如果队列不为空，我们成功获取了 sem\_full\_。然后，分别在 [2] 和 [3] 中读取项目并更新 head\_。最后，我们向消费者线程发出信号，告知队列未满，释放 sem\_e mpty。

我们的第一个版本的 push 存在几个问题。第一个也是最重要的问题是 sem\_empty\_ 允许多个线程访问队列中的临界区（[2] 和 [3]）。我们需要同步这个临界区并使用互斥锁。

这是使用互斥锁进行同步的新版本的推送。

在 [2] 中，获取了锁（使用 std::unique\_lock），在 [5] 中，释放了锁。使用锁将同步临界区，防止多个线程同时访问它并在没有任何同步的情况下并发更新队列：

\begin{cpp}
void push(const T& item)
{
    sem_empty_.acquire();

    std::unique_lock<std::mutex> lock(mtx_);
    buffer_[tail_] = item;
    tail_ = next(tail_);
    lock.unlock();

    sem_full_.release();
}
\end{cpp}

第二个问题是获取信号量是阻塞的，正如我们之前所见，有时调用者线程可以做一些处理，而不仅仅是等待。 try\_push 函数（及其对应的 try\_pop 函数）实现了此功能。让我们研究一下 try\_push 的代码。请注意， try\_push 可能仍会在互斥锁上阻塞：

\begin{cpp}
bool try_push(const T& item) {
    if (!sem_empty_.try acquire()) {
        return false;
    }

    std::unique_lock<std::mutex> lock(mtx_);

    buffer_[tail_] = item;
    tail_ = next(tail_);

    lock.unlock();

    sem_full_.release();

    return true;
}
\end{cpp}

唯一的变化是 [1] 和 [2]。获取信号量时不再阻塞，而是尝试获取，如果失败，则返回 false 。即使可以获取信号量（计数不为零）， try\_acquire 函数也可能虚假失败并返回 false。

以下是使用信号量同步的队列的完整代码：

\begin{cpp}
#pragma once

#include <mutex>
#include <semaphore>
#include <vector>

namespace async_prog {
template <typename T>
class semaphore_queue {
public:
    semaphore_queue(std::size_t capacity)
    : sem_empty_(capacity), sem_full_(0), capacity_{capacity},
    buffer_(capacity)
    {}

    void push(const T& item) {
        sem_empty_.acquire();

        std::unique_lock<std::mutex> lock(mtx_);

        buffer_[tail_] = item;
        tail_ = next(tail_);

        lock.unlock();

        sem_full_.release();
    }

    bool try_push(const T& item) {
        if (!sem_empty_.try_acquire()) {
            return false;
        }

        std::unique_lock<std::mutex> lock(mtx_);

        buffer_[tail_] = item;
        tail_ = next(tail_);

        lock.unlock();
        sem_full_.release();
        return true;
    }

    void pop(T& item) {
        sem_full_.acquire();

        std::unique_lock<std::mutex> lock(mtx_);

        item = buffer_[head_];
        head_ = next(head_);

        lock.unlock();
        sem_empty_.release();
    }

    bool try_pop(T& item) {
        if (!sem_full_.try_acquire()) {
            return false;
        }

        std::unique_lock<std::mutex> lock(mtx_);

        item = buffer_[head_];
        head_ = next(head_);

        lock.unlock();
        sem_empty_.release();

        return true;
    }
private:
    [[nodiscard]] std::size_t next(std::size_t idx) const noexcept {
        return ((idx + 1) % capacity_);
    }
private:
    std::mutex mtx_;
    std::counting_semaphore<> sem_empty_;
    std::counting_semaphore<> sem_full_;

    std::size_t head_{0};
    std::size_t tail_{0};
    std::size_t capacity_;
    std::vector<T> buffer_;
};
\end{cpp}

在本节中，我们了解了信号量，这是自 C++20 以来包含在 C++ 标准库中的一种新同步原语。我们学习了如何使用它们来实现我们之前实现的相同队列，但使用信号量作为同步原语。

在下一节中，我们将介绍栅栏和闩锁，这是自 C++20 以来 C++ 标准库中包含的两种新同步机制。





