在本节中，我们将了解如何实现一个简单的多线程安全队列。该队列将由多个线程访问，其中一些线程向队列添加元素（生产者线程），一些线程从队列中删除元素（消费者线程）。首先，我们假设只有两个线程：一个生产者线程和一个消费者线程。

队列或先进先出 (FIFO) 是线程间通信的标准方式。例如，如果我们需要尽快从网络连接接收包含数据的数据包，那么我们可能没有足够的时间在一个线程中接收所有数据包并处理它们。在这种情况下，我们使用第二个线程来处理第一个线程读取的数据包。只使用一个消费者线程更容易同步（我们将在第 5 章中看到这种情况），并且我们可以保证数据包将按照它们到达并被生产者线程复制到队列的顺序进行处理。确实，无论我们有多少个作为消费者的线程，数据包的读取顺序实际上都会与复制到队列的顺序相同，但消费者线程可能会由操作系统调度进出，并且处理后的数据包的完整序列可能会按不同的顺序进行。

一般来说，最简单的问题是单生产者单消费者 (SPSC) 队列。如果处理每个项目对于一个线程来说成本太高，不同的问题可能需要多个消费者，并且我们可能有不同的数据源需要处理，需要多个生产者线程。本节中描述的队列适用于每种情况。

设计队列的第一步是决定使用什么数据结构来存储队列中的项目。我们希望队列包含任何类型 T 的元素，因此我们将将其实现为模板类。此外，我们将限制队列的容量，以便我们可以在队列中存储的最大元素数是固定的，并在类构造函数中设置。例如，可以使用链接列表并使队列不受限制，甚至可以使用标准模板库 (STL) 队列 std::queue，并让队列增长到任意大小。在本章中，我们将实现一个固定大小的队列。我们将在第 5 章中重新讨论实现，并以非常不同的方式实现它（我们不会使用任何互斥锁或等待条件变量）。对于我们当前的实现，我们将使用 STL 向量 std::vector<T> 来存储队列中的项目。向量将为队列类构造函数中的所有元素分配内存，因此之后不会有内存分配即。当队列被销毁时， vector 将销毁自身并释放分配的内存。这很方便，并简化了实现。

我们将使用向量作为环形缓冲区。这意味着，一旦我们将一个元素存储在向量的末尾，下一个元素将存储在开头，因此我们绕行两个位置来从向量中写入和读取元素。

这是队列类的第一个版本，相当简单并且尚未实用：

\begin{cpp}
template <typename T>
class synchronized_queue {
public:
    explicit synchronized_queue(size_t size) :
        capacity_{ size }, buffer_(capacity_)
        {}

private:
    std::size_t head_{ 0 };
    std::size_t tail_{ 0 };
    std::size_t capacity_;
    std::vector<T> buffer_;
};
\end{cpp}

head 和 tail 变量分别用于指示在何处读取或写入下一个元素。我们还需要知道队列何时为空或满。如果队列为空，则消费者线程将无法从队列中获取任何项目。如果队列已满，则生产者线程将无法将任何项目放入队列中。

有多种方式来指示队列何时为空以及何时为满。在此示例中，我们遵循以下约定：

\begin{itemize}
\item
如果 \verb|tail_ == head_|，则队列为空

\item
如果 \verb|(tail_ + 1) % capacity_ == head_|, 则队列已满
\end{itemize}

另一种实现方法是仅检查 tail\_ == head\_ 是否为空，并使用额外的标志来指示队列是否已满（或使用计数器来了解队列中有多少项）。我们在此示例中避免使用任何额外的标志或计数器，因为标志将由消费者和生产者线程读取和写入，并且我们的目标是尽可能减少线程之间的数据共享。此外，当我们在第 5 章中重新讨论队列的实现时，减少数据共享将是唯一的选择。

这里有一个小问题。由于我们检查队列是否已满的方式，我们在缓冲区中丢失了一个插槽，因此实际容量是 capacity\_ - 1。当只有一个空插槽时，我们会将队列视为已满。因此，我们丢失了一个队列插槽（请注意，该插槽将被使用，但当项目数为 capacity\_ - 1 时，队列仍将为满）。一般来说，这不是问题。

我们要实现的队列是一个以环形缓冲区实现的有界队列（固定大小）。

这里还有另一个细节需要考虑： head\_ + 1 必须考虑到我们将索引环绕到缓冲区（它是一个环形缓冲区）。因此，我们必须执行 (head\_ + 1) \% capacity\_。模数运算符计算索引值除以队列容量后的余数。

以下代码展示了在同步队列中作为辅助函数实现的基本实用函数：

\begin{cpp}
template <typename T>
class synchronized_queue {
public:
    explicit synchronized_queue(size_t size) :
        capacity_{ size }, buffer_(capacity_) {
    }

private:
    std::size_t next(std::size_t index) {
        return (index + 1)% capacity_;
    }
    bool is_full() const {
        return next(tail_) == head_;
    }
    bool is_empty() const {
        return tail_ == head_;
    }

    std::size_t head_{ 0 };
    std::size_t tail_{ 0 };
    std::size_t capacity_;
    std::vector<T> buffer_;
};
\end{cpp}

我们已经实现了一些有用的函数来更新环形缓冲区的头部和尾部，并检查缓冲区是满的还是空的。现在，我们可以开始实现队列功能了。

完整队列实现的代码位于本书的 GitHub 存储库中。这里，我们仅展示重要部分以简化流程，并仅关注队列实现的同步方面。

队列的接口有以下两个功能：

\begin{cpp}
void push(const T& item);
void pop(T& item);
\end{cpp}

push 函数将一个元素插入队列，而 pop 函数从队列中获取一个元素。

让我们从推送开始。它在队列中插入一个项目。如果队列已满，推送将等待，直到队列至少有一个空槽（消费者从队列中删除了一个元素）。这样，生产者线程将被阻塞，直到队列至少有一个空槽（满足未满条件）。

我们在本章前面已经看到，有一种称为条件变量的同步机制可以实现这一点。 push 函数将检查条件是否满足，如果满足，它将在队列中插入一个项目。如果条件不满足，则将释放与条件变量关联的锁，并且线程将等待条件变量，直到条件得到满足。

条件变量可以一直等待直到锁被释放。我们仍然需要检查队列是否已满，因为条件变量可能会因虚假唤醒而结束等待。当条件变量收到任何其他线程未明确发送的通知时，就会发生这种情况。
我们向队列类中添加如下三个成员变量

\begin{cpp}
std::mutex mtx_;
std::condition_variable not_full_;
Std::condition_variable not_empty_;
\end{cpp}

我们需要两个条件变量——一个用于通知消费者队列未满（not\_full\_），另一个用于通知生产者队列不为空（not\_empty\_）。

这是实现推送的代码：

\begin{cpp}
void push(const T& item) {
    std::unique_lock<std::mutex> lock(mtx_);
    not_full_.wait(lock, [this]{ return !is_full(); });

    buffer_[tail_] = T;
    tail_ = increment(tail_);

    lock.unlock();
    not_empty_.notify_one();
}
\end{cpp}

让我们考虑一个只有一个生产者和一个消费者的场景。稍后我们将看到 pop 函数，但作为一项进步，它还与互斥/条件变量同步。两个线程都尝试同时访问队列——生产者在插入元素时，消费者在移除元素时。

假设消费者首先获取锁。这发生在 [1] 中。条件变量需要使用 std::unique\_lock 才能使用互斥锁。在 [2] 中，我们等待条件变量，直到满足等待函数谓词中的条件。如果不满足，则释放锁，以便消费者线程能够访问队列。

一旦满足条件，就会再次获取锁，并在 [3] 中更新队列。更新队列后， [4] 释放锁，然后 [5] 通知可能正在等待 not\_empty 的消费者线程，队列现在实际上不为空。

std::unique\_lock 类可以在其析构函数中释放互斥锁，但我们需要在 [4] 中释放它，因为我们不想在通知条件变量后释放锁。

pop() 函数遵循类似的逻辑，如下面的代码所示：

\begin{cpp}
void pop(T& item)
{
    std::unique_lock<std::mutex> lock(mtx_);
    not_empty_.wait(lock, [this]{return !is_empty()});

    item = buffer_[head_];
    head_ = increment(head_);

    lock.unlock();
    not_full_.notify_one();
}
\end{cpp}

该代码与 push 函数中的代码非常相似。 [1] 创建使用 not\_empty\_ 条件变量所需的 std::unique\_lock 类。 [2] 等待 not\_empty\_，直到收到队列不为空的通知。 [3] 从队列中读取项目，将其分配给 item 变量，然后在 [4] 中释放锁。最后，在 [5] 中，通知 not\_full\_ 条件变量以向消费者指示队列未满。

推送和弹出函数都是阻塞的，并且分别等待队列不满或空。我们可能需要线程在无法向队列插入消息或从队列中获取消息时继续运行（例如，让它进行一些独立处理），然后再次尝试访问队列。

try\_push 函数正是这样做的。如果可以自由获取互斥锁并且队列未满，则功能与 push 函数相同，但在这种情况下， try\_push 不需要使用任何条件变量进行同步（但必须通知消费者） 。这是 try\_push 的代码：

\begin{cpp}
bool try_push(const T& item) {
    std::unique_lock<std::mutex> lock(mtx_, std::try_to_lock);
    if (!lock || is_full()) {
        return false;
    }

    buffer_[tail_] = item;
    tail_ = next(tail_);

    lock.unlock();

    not_empty_.notify_one();

    return true;
}
\end{cpp}

代码的工作原理如下： [1] 尝试获取锁并返回，而不会阻塞调用线程。如果已获取锁，则计算结果为 false。在 [2] 中，如果尚未获取锁或队列已满， try\_push 将返回 false，以向调用者指示队列中未插入任何项目，并将等待/阻塞委托给调用者。请注意， [3] 返回 false，函数终止。如果已获取锁，则在函数退出并调用 std::unique\_lock 析构函数时将释放锁。

获取锁并检查队列未满后，将项目插入队列，并更新 tail\_。在 [5] 中，释放锁，在 [6] 中，通知消费者队列不再为空。此通知是必需的，因为消费者可能会调用 pop 而不是 try\_pop。
最后，函数返回 true 来向调用者表明该项目已成功插入队列。

对应的 try\_pop 函数的代码如下所示。作为练习，尝试理解它的工作原理：

\begin{cpp}
bool try_pop(T& item) {
    std::unique_lock<std::mutex> lock(mtx_, std::try_to_lock);
    if (!lock || is_empty()) {
        return false;
    }

    item = buffer_[head_];
    head_ = next(head_);

    lock.unlock();

    not_empty_.notify_one();

    return true;
}
\end{cpp}

这是我们在本节中实现的队列的完整代码：

\begin{cpp}
#pragma once

#include <condition_variable>
#include <mutex>
#include <vector>

namespace async_prog {
template <typename T>
class queue {
public:
    queue(std::size_t capacity) : capacity_{capacity}, buffer_
    (capacity) {}
    void push(const T& item) {
        std::unique_lock<std::mutex> lock(mtx_);
        not_full_.wait(lock, [this] { return !is_full(); });

        buffer_[tail_] = item;
        tail_ = next(tail_);

        lock.unlock();
        not_empty_.notify_one();
    }

    bool try_push(const T& item) {
        std::unique_lock<std::mutex> lock(mtx_, std::try_to_lock);
        if (!lock || is_full()) {
            return false;
        }

        buffer_[tail_] = item;
        tail_ = next(tail_);

        lock.unlock();

        not_empty_.notify_one();

        return true;
    }

    void pop(T& item) {
        std::unique_lock<std::mutex> lock(mtx_);
        not_empty_.wait(lock, [this] { return !is_empty(); });

        item = buffer_[head_];
        head_ = next(head_);

        lock.unlock();

        not_full_.notify_one();
    }

    bool try_pop(T& item) {
        std::unique_lock<std::mutex> lock(mtx_, std::try_to_lock);
        if (!lock || is_empty()) {
            return false;
        }

        item = buffer_[head_];
        head_ = next(head_);

        lock.unlock();

        not_empty_.notify_one();

        return true;
    }

private:
    [[nodiscard]] std::size_t next(std::size_t idx) const noexcept {
        return ((idx + 1) % capacity_);
    }

    [[nodiscard]] bool is_empty() const noexcept { return (head_ ==
    tail_); }

    [[nodiscard]] bool is_full() const noexcept { return (next(tail_)
    == head_); }

private:
    std::mutex mtx_;
    std::condition_variable not_empty_;
    std::condition_variable not_full_;

    std::size_t head_{0};
    std::size_t tail_{0};
    std::size_t capacity_;
    std::vector<T> buffer_;
};
}
\end{cpp}

在本节中，我们引入了条件变量并实现了一个与互斥锁和两个条件变量同步的基本队列，这是 C++11 以来 C++ 标准库提供的两个基本同步原语。

队列示例展示了如何使用这些同步原语实现同步，并且可以用作更复杂的实用程序（例如线程池）的基本构建块。










