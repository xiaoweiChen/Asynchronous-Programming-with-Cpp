
第 8 章中介绍了 C++20 如何支持协程。显然，编写协程并不是一件容易的事，主要有两个原因：

\begin{itemize}
\item
在 C++ 中编写协程需要一定数量的代码才能使协程工作，但与想要实现的功能无关。例如，编写的用于生成斐波那契数列的协程非常简单，但必须实现包装器类型、promise，以及使其可用所需的所有函数。

\item
开发普通的 C++20 协程需要很好地了解协程在 C++ 中实现的底层方面，编译器如何转换代码以实现保持协程状态所需的所有机制，以及如何调用和何时调用，函数必须详尽的实现。
\end{itemize}

即使没有那么多细节，异步编程也已经够难了。如果能专注于我们的程序，远离底层概念和代码，那就好了。我们看到了 C++23 如何引入 std::generator 来实现这一点，只编写生成器代码，让 C++ 标准库和编译器处理其余部分。预计这种协程支持将在下一个 C++ 版本中得到改进。

Boost.Cobalt 是 Boost C++ 库中包含的库之一，可做到这一点 - 避免实现协程细节。 Boost.Cobalt 是在 Boost 1.84 中引入的，并且需要 C++20。基于Boost.Asio，可以在程序中使用这两个库。

Boost.Cobalt 的目标是使用协程编写简单的单线程异步代码 - 可以在单个线程中同时执行多项操作的应用程序。当然，这里所说的同时是指并发，而不是并行，因为只有一个线程。通过使用 Boost.Asio 多线程功能，可以在不同的线程中执行协程，但在本章中，将重点介绍单线程应用程序。

\mySubsubsection{10.2.1.}{立即和惰性协程}

介绍Boost.Cobalt实现的协程类型之前，需要定义两种协程：

\begin{itemize}
\item
立即协程：立即协程在调用后立即开始执行。协程逻辑立即开始运行，并按照其序列进行，直到到达暂停点（例如 co\_await 或 co\_yield）。协程的创建实际上启动了其处理，并且其主体中的任何副作用都将立即生效。

当希望协程在创建后立即启动其工作（例如启动异步网络操作或准备数据）时，立即协程非常有用。

\item
惰性协程：惰性协程会推迟执行，直到明确等待或使用。可以在不运行主体的情况下创建协程对象，直到调用者决定与其交互（通常通过使用 co\_await 等待它）。

当想要设置一个协程但延迟其执行直到满足某个条件或需要将其执行与其他任务协调时，惰性协程很有用。
\end{itemize}

定义了立即协程和惰性协程之后，我们将介绍在 Boost.Cobalt 中实现的不同类型的协程。

\mySubsubsection{10.2.2.}{Boost.Cobalt 协程类型}

Boost.Cobalt 实现了四种类型的协程。我们将在本节中介绍它们，然后在本章后面查看一些示例：

\begin{itemize}
\item
Promise：这是 Boost.Cobalt 中的主要协程类型，用于实现返回单个值的异步操作（调用 co\_return）。它是一个立即协程，支持 co\_await，允许异步暂停和继续。例如，promise 可用于执行网络调用，完成后将返回其结果而不会阻止其他操作。

\item
任务：任务是 Promise 的惰性版本，直到明确等待时才会开始执行。提供了更大的灵活性来控制协程的运行时间和方式。等待时，任务开始执行，允许延迟处理异步操作。

\item
生成器：在 Boost.Cobalt 中，生成器是唯一可以产生值的协程类型。每个值都使用 co\_yield 单独产生。其功能类似于 C++23 中的 std::generator，但允许使用 co\_await 进行等待（std::generator 不允许）。

\item
分离：这是一个可以使用 co\_await 但不能使用 co\_return 值的立即协程。它无法恢复，通常也不会等待。
\end{itemize}

目前为止，我们介绍了 Boost.Cobalt。定义了什么是急切协程和惰性协程，然后定义了库中的四种主要协程类型。

下一节中，将深入探讨与 Boost.Cobalt 相关的最重要的主题之一 - 生成器；还将实现一些简单的生成器示例。














































