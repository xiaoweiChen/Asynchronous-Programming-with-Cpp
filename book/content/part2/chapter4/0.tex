在第 2 章中，我们了解到线程可以读取和写入它们所属进程共享的内存。虽然操作系统实现了进程内存访问保护，但对于访问同一进程中共享内存的线程，并没有这样的保护。多个线程对同一内存地址的并发内存写入操作需要同步机制来避免数据争用并确保数据完整性。

在本章中，我们将详细描述多个线程并发访问共享内存所产生的问题以及如何解决这些问题。我们将详细研究以下主题：

\begin{itemize}
\item
竞争条件 – 它们是什么以及如何发生

\item
互斥作为一种同步机制以及它如何通过 std::mutex 在 C++ 中实现

\item
通用锁管理

\item
什么是条件变量以及如何将它们与互斥锁一起使用

\item
使用 std::mutex 和 \verb|std::condition_variable|实现完全同步队列

\item
C++20 引入的新同步原语 - 信号量、栅栏和闩锁
\end{itemize}

这些都是基于锁的同步机制。无锁技术是下一章的主题。
