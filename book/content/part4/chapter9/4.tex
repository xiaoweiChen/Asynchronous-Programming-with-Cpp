使用事件处理应用程序时，可以遵循两种方法来设计并发解决方案： Reactor(反应堆) 和 Proactor(前摄器)设计模式。这些模式描述了处理事件所遵循的机制，表明如何发起、接收、解复用和分派这些事件。当系统收集并排队来自不同资源的 I/O 事件时，解复用这些事件，将它们分离并分派给正确的处理程序。

Reactor 模式以同步、串行的方式对服务请求进行多路分解和分派。通常遵循非阻塞同步I/O 策略，如果操作可以执行则返回结果，如果系统没有资源来完成操作则返回错误。

而Proactor模式则允许以高效的异步方式解复用和调度服务请求，立即将控制权返回给调用者，表明操作已启动。然后，当操作完成时，调用系统将通知调用者。因此，Proactor模式将责任分配给两个任务：异步执行的长时间操作和处理结果并通常调用其他异步操作的完成处理程序。

Boost.Asio通过使用以下元素实现了Proactor设计模式：

\begin{itemize}
\item
发起者：发起异步操作的 I/O 对象。

\item
异步操作：由操作系统异步运行的任务。

\item
异步操作处理器：执行异步操作并将结果排队到完成事件队列中。

\item
完成事件队列：异步操作处理器推送事件，异步事件出队的事件队列。

\item
异步事件多路分解器：这会阻止 I/O 上下文，等待事件，并将完成的事件返回给调用者。

\item
完成处理程序：处理异步操作结果的可调用对象。

\item
Proactor：调用异步事件多路分解器来将事件从队列中取出，并将它们分派给完成处理程序。这就是 I/O 执行上下文所做的工作。
\end{itemize}

图 9.3 清楚地显示了所有这些元素之间的关系：

\myGraphic{1.0}{content/part4/chapter9/images/3.png}{图 9.3 – {} 前摄器设计模式}

Proactor模式在封装并发机制、简化应用程序同步、提高性能的同时，分离了关注点。

另一方面，无法控制异步操作的调度方式和时间，也无法控制操作系统执行这些操作的效率。此外，由于完成事件队列的存在，内存使用量也会增加，调试和测试的复杂性也会增加。

Boost.Asio 设计的另一个方面是执行上下文对象的线程安全性。现在，来深入研究 Boost.Asio 的线程工作原理。
































