当任务或计算同时完成时，就会发生并行计算，其中任务是软件应用程序中的执行单元或工作单元。由于实现并行性的方法有很多，因此了解不同的方法将有助于编写高效的并行算法。这些方法通过范例和模型进行描述。

但首先，让我们首先对不同的并行计算系统进行分类。

\mySubsubsection{1.2.1.}{系统分类和技术}

并行计算系统最早的分类之一是由 Michael J. Flynn 于 1966 年提出的。 Flynn 的分类法根据并行计算架构可以处理的数据流和指令数量定义了以下分类：

\begin{itemize}
\item
单指令单数据 (SISD) 系统：定义顺序程序

\item
单指令多数据 (SIMD) 系统：对大型数据集进行操作，例如 GPU 计算的信号处理

\item
多指令单数据 (MISD) 系统：很少使用

\item
多指令多数据 (MIMD) 系统：基于多核和多处理器计算机的最常见并行架构
\end{itemize}

\myGraphic{0.5}{content/part1/chapter1/images/1.png}{图 1.1：弗林的分类法}

本书不仅介绍了如何使用 C++ 构建软件，还介绍了它如何与底层硬件交互。在软件层面，我们可能可以进行更有趣的划分或分类，在那里我们可以定义技术。我们将在后续章节中了解这些内容。

\mySamllsection{数据并行}

许多不同的数据单元由在不同处理单元（例如 CPU 或 GPU 核心）中运行的同一程序或指令序列并行处理。

数据并行性是通过相同操作同时处理多少个不相交的数据集来实现的。利用并行性，可以将大型数据集划分为更小且独立的数据块。

该技术还具有高度的可扩展性，因为添加更多处理单元可以处理大量数据。

在这个子集中，我们可以包含 SIMD 指令集，例如 SSE、 AVX、 VMX 或 NEON，这些指令集可通过 C++ 中的内部函数访问。此外，还有用于 NVIDIA GPU 的 OpenMP 和 CUDA 等库。在机器学习训练和图像处理中可以找到它的一些使用示例。该技术与 Flynn 定义的 SIM D 分类法有关。

和往常一样，它也存在一些缺点。数据必须能够轻松划分为独立的块。这种数据划分和后验合并也会带来一些开销，从而降低并行化的优势。

\mySamllsection{任务并行}

在每个 CPU 核心使用进程或线程运行不同任务的计算机中，当这些任务同时接收数据、处理数据并通过消息传递发回它们生成的结果时，就可以实现任务并行。

任务并行的优势在于能够设计异构、细粒度的任务，从而更好地利用处理资源，在设计具有潜在更高加速的解决方案时更加灵活。

由于数据可能创建的任务之间存在依赖关系，并且每个任务的性质不同，因此调度和协调比数据并行更复杂。此外，任务创建会增加一些处理开销。

这里我们可以引入 Flynn 的 MISD 和 MIMD 分类法。可以在 Web 服务器请求处理系统或用户界面事件处理程序中找到一些示例。

\mySamllsection{流并行}

可以通过将计算分为处理数据子集的各个阶段来同时处理连续的数据元素序列（也称为数据流）。

阶段可以同时运行。一些阶段生成其他阶段的输入，根据阶段依赖关系构建管道。处理阶段可以将结果发送到下一个阶段，而无需等待接收整个流数据。

流并行技术在处理连续数据时非常有效。它们还具有高度可扩展性，因为它们可以通过添加更多处理单元来处理额外的输入数据。由于流数据在到达时进行处理，这意味着无需等待整个数据流发送，这也意味着内存使用量也减少了。

然而，像往常一样，这些系统也存在一些缺点。由于它们的处理逻辑、错误处理和恢复，这些系统的实现更加复杂。由于我们可能还需要实时处理数据流，因此硬件也可能是一个限制。

这些系统的一些示例包括监控系统、传感器数据处理以及音频和视频流。

\mySamllsection{隐式并行}

在这种情况下，编译器、运行时或硬件会负责对程序员透明地并行执行指令。

这使得编写并行程序变得更容易，但限制了程序员对所用策略的控制，甚至使分析性能或调试变得更加困难。

现在我们对不同的并行系统和技术有了更好的了解，是时候了解在设计并行程序时可以使用的不同模型了。

\mySubsubsection{1.2.2.}{并行编程模型}

并行编程模型是一种并行计算机架构，用于表达算法和构建程序。模型越通用，其价值就越大，因为它可以用于更广泛的场景。从这个意义上讲， C++ 通过标准模板库 (STL) 中的库实现了并行模型，可用于实现顺序应用程序中程序的并行执行。

这些模型描述了程序生命周期内不同任务如何交互以从输入数据中获取结果。它们的主要区别在于任务如何交互以及如何处理传入数据。

\mySamllsection{阶段并行}

在阶段并行（也称为议程或松散同步范式）中，多个作业或任务并行执行独立计算。在某个时刻，程序需要使用屏障执行同步交互操作来同步不同的进程。屏障是一种同步机制，可确保一组任务在其执行过程中到达特定点执行完后，其中任何一个步骤才能继续进行。接下来的步骤将执行其他异步操作，依此类推。

\myGraphic{0.8}{content/part1/chapter1/images/2.png}{图1.2：阶段并行}

这种模型的优点是任务间的交互不会与计算重叠，但另一方面各个处理单元之间的工作量和吞吐量很难达到均衡。

\mySamllsection{分而治之}

使用此模型的应用程序使用主任务或作业，将工作量分配给其子任务，并将它们分配给较小的任务。

子任务并行计算结果并将其返回给父任务，父任务将部分结果合并为最终结果。子任务还可以将分配的任务细分为更小的任务并创建自己的子任务。

该模型具有与相并联模型相同的缺点，很难实现良好的负载平衡。

\myGraphic{0.5}{content/part1/chapter1/images/3.png}{图 1.3：分而治之模型}

在图 1.3 中，我们可以看到主作业如何将工作划分给几个子任务，以及子任务 2 如何将其分配的工作细分为两个附加任务。

\mySamllsection{管道模型}

多个任务相互连接，构建虚拟管道。在此管道中，各个阶段可以同时运行，并在输入数据时重叠执行。

\myGraphic{1.0}{content/part1/chapter1/images/4.png}{图 1.4：管道模型}

上图中三个任务在由五个阶段组成的流水线中交互，每个阶段中都有一些任务在运行，并产生输出结果，供下一个阶段的其他任务使用。

\mySamllsection{主从模型}

使用主从模型（也称为进程农场），主作业执行算法的顺序部分，并生成和协调在工作负载中执行并行操作的从属任务。当从属任务完成计算时，它会将结果通知主作业，然后主作业可能会将更多数据发送给从属任务进行处理。

\myGraphic{0.5}{content/part1/chapter1/images/5.png}{图 1.5：主从模型}

主要缺点是，如果主服务器需要处理太多从服务器或任务太小，主服务器可能会成为瓶颈
。在选择由主服务器执行的工作量时，需要权衡每个任务，也称为粒度。当任务较小时，称为细粒度，当任务较大时，称为粗粒度。

\mySamllsection{工作池}

在工作池模型中，全局结构保存着要执行的工作项池。然后，主程序会创建作业，从池中获取工作项并执行它们。

这些作业可以生成更多工作单元，并将它们插入到工作池中。当所有工作单元都完成后，并行程序便会结束执行，工作池也就空了。

\myGraphic{0.5}{content/part1/chapter1/images/6.png}{图 1.6：工作池模型}

该机制有利于实现空闲处理单元之间的负载平衡。

在 C++ 中，这个池通常使用无序集合、队列或优先级队列来实现。我们将在本书中实现一些示例。

现在我们已经了解了可用于构建并行系统的各种模型，让我们探索可用于开发高效并行运行任务的软件的不同并行编程范例。





























