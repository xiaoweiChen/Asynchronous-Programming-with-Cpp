
原子操作是不可分割的（“原子”这个词源自希腊语ἄτομος， atomos，不可分割）。在本节中，将介绍原子操作、其是什么，以及使用（和不使用）原子操作的原因。

\mySubsubsection{5.2.1.}{原子操作与非原子操作——示例}

如果还记得第 4 章中的简单计数器示例，其中需要使用同步机制（我们使用了互斥锁） 来从不同线程修改计数器变量以避免条件竞争。条件竞争的原因是增加计数器需要三个操作：读取计数器值、增加计数器值，以及将修改后的计数器值写回内存。如果能一次性完成这些操作，就不会出现条件竞争。

这正是原子操作可以实现的：如果有某种原子增量操作，每个线程都可以在一条指令中读取、增量和写入计数器，从而避免条件竞争，那么计数器增量操作都会完全完成。所谓完全完成，是每个线程要么增加计数器，要么什么都不做，这样就不可能在计数器增量操作的中间中断。

以下两个示例仅用于说明目的，并非多线程。在此仅关注操作，无论是原子操作还是非原子操作。

有关以下示例中显示的 C++ 代码和生成的汇编语言，请参阅\url{https://godbolt.org/z/f4dTacsKW}：

\begin{cpp}
int counter {0};
int main() {
    counter++;
    return 0;
}
\end{cpp}

代码增加了一个全局计数器。现在让我们看看编译器生成的汇编代码以及 CPU 执行了哪些指令（完整汇编代码可以在前面的链接中找到）：

\begin{cpp}
Mov eax, DWORD PTR counter[rip] // [1]
Add eax, 1 // [2]
Move DWORD PTR counter[rip], eax // [3]
\end{cpp}

[1] 将存储在 counter 中的值复制到 eax 寄存器， [2] 将存储在 eax 中的值加 1，最后， [3] 将eax 寄存器的内容复制回 counter 变量。因此，线程可以执行 [1]，然后调度出去，然后另一个线程执行所有三个指令。当第一个线程完成结果递增时，计数器将仅递增一次，因此结果不正确。

以下代码的作用相同：增加一个全局计数器。不过，这次使用了原子类型和操作。要获取以下示例中的代码和生成的程序集，请参阅 \url{https://godbolt.org/z/9hrbo31vx}：

\begin{cpp}
#include <atomic>
std::atomic<int> counter {0};
int main() {
    counter++;
    return 0;
}
\end{cpp}

稍后会解释 std::atomic<int> 类型和原子增量操作。生成的汇编代码如下：

\begin{cpp}
lock add DWORD PTR counter[rip], 1
\end{cpp}

只生成了一条指令，用于将存储在计数器变量中的值加 1。此处的 lock 前缀表示以下指令（本例中为 add）将以原子方式执行。第二个示例中，线程在增加计数器的过程中不能中断。顺便提一下，一些 Intel x64 指令以原子方式执行，不使用 lock 前缀。

原子操作允许线程不可分割地读取、修改（例如，增加一个值）和写入，也可以用作同步原语（类似于我们在第 4 章中看到的互斥锁）。目前为止，本书中看到的所有基于锁的同步原语都是使用原子操作实现的，原子操作必须由 CPU 提供（如 lock add 指令）。

本节中，介绍了原子操作，定义了原子操作，并通过查看编译器生成的汇编指令研究了一个非常简单的原子操作实现示例。在下一节中，将介绍原子操作的一些优点和缺点。

\mySubsubsection{5.2.2.}{何时使用（何时不使用）原子操作}

使用原子操作是一个复杂的主题，需要大量的经验，我们参加了一些关于这个主题的课程，有人建议我们不要这样做！无论如何，总是可以学习基础知识并在学习过程中进行实验。希望这本书能帮助各位在学习之旅中取得进步。

原子操作可以在以下情况下使用：

\begin{itemize}
\item
如果多个线程共享一个可变状态：需要同步线程是最常见的情况。当然，可以使用互斥锁之类的锁，但有时原子操作会提供更好的性能，但使用原子操作并不能保证更好的性能。

\item
如果对共享状态的同步访问是细粒度的：如果必须同步的数据是整数、指针或其他 C++ 内在类型的变量，使用原子操作可能比使用锁更好。

\item
提高性能：如果想要实现最大性能，原子操作可以帮助减少线程上下文切换（参见第 2 章）并减少锁带来的开销，从而降低延迟。请记住，分析代码以确保性能得到改善（ 将在第 13 章中深入了解这一点）。
\end{itemize}

锁可以在下列情况下使用：

\begin{itemize}
\item
如果受保护的数据不是细粒度的：例如，正在同步对大于 8 个字节的数据结构或对象的访问（现代 CPU 中）。

\item
如果性能不是问题：锁的使用和推理就简单得多（某些情况下，使用锁比使用原子操作具有更好的性能）。

\item
避免获取底层知识：要从原子操作中获得最大性能，需要大量的底层知识。我们将在 C++ 内存模型部分介绍其中的一些内容。
\end{itemize}

刚刚介绍了何时使用和何时不使用原子操作，某些应用程序（例如低延迟/高频交易系统）需要最大性能并使用原子操作来实现尽可能低的延迟。大多数应用程序都可以很好地与锁同步。

下一节将研究阻塞和非阻塞数据结构的区别，以及一些相关的概念定义。







