正如我们在本章中看到的， std::async 不提供对所用线程数或对线程对象本身的访问的直接控制。我们现在知道如何通过使用计数信号量来限制异步任务的数量，但在某些应用程序中，这可能不是最佳解决方案，需要细粒度的控制。

此外，线程的自动管理可能会引入开销，从而降低性能，尤其是在启动许多小任务时，会导致过多的上下文切换和资源争用。

该实现对可使用的并发线程数施加了一些限制，这可能会降低性能甚至引发异常。由于 std: :async 和可用的 std::launch 策略依赖于实现，因此不同编译器和平台之间的性能并不一致。

最后，在本章中，我们没有提到如何取消由 std::async 启动的异步任务，因为在完成之前没有标准的方法。